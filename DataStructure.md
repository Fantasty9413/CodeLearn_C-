# Data Structure

## 线性表

### 单链表

* 单链表的节点的典型定义：

  ```c++
  // Definition for singly-linked list.
  struct SinglyListNode {
      int val;
      SinglyListNode *next;
      SinglyListNode(int x) : val(x), next(NULL) {}
  };
  ```

* 单链表的插入：

  * 过程：1.创建新节点cur 2.cur指向next 3.prev指向cur。一句话概括：让新来的节点有指向。
  * 复杂度：时间复杂度O（1）

  ![image-20220314203840940](C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220314203840940.png)

* 单链表的删除：

  * 过程：1.找到cur节点 2.pre指向next
  * 复杂度：时间复杂度O(N)，空间复杂度O（1）。

  ![image-20220314204341452](C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220314204341452.png)

* 技巧：

  * 定位至第i个节点

    ```c++
    node *cur = head;
    while(i--)
    {
    	cur = cur->next;
    } 
    ```

* 链表与数组的区别
  
  > 如果你需要经常添加或删除结点，链表可能是一个不错的选择。
  >
  > 如果你需要经常按索引访问元素，数组可能是比链表更好的选择。
  
  <img src="C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220319205913691.png" alt="image-20220319205913691" style="zoom:50%;" />
  
* 单链表的删除（倒数节点+一次遍历）

  * 问题：删除单链表中的倒数第n个节点，并且只用一次循环遍历。
  * 解决方案：利用**快慢指针-间隔指针**定位要删除的节点。先让快指针和慢指针**间隔n-1个节点**（快指针先出发**走n步**，慢指针后出发），然后快慢指针同时前进，当快指针到达尾节点时，慢指针到达要被删除的节点。
  * 要点：
    * **快指针要到尾节点，或者尾节点的next（即为null）**
    * 删除节点有两种情况：1.删除中间节点，需要pre节点的信息（对应快指针到尾节点）。2.**删除头节点**（对应快指针到next）。

* 删除单链表中的固定元素

  * 问题：删除单链表中的节点值为指定值的节点
  * 思路：依次查找并进行删除。[示例](.\datastruct\SingleList_4.cpp)
  * 要点：删除单链表中的节点，要区分头节点和其他节点，二者的删除操作方式不同。方法一：先处理其他节点，再最后来处理头节点。方法二：增加伪头节点，将整个链表作为新链表的其他节点进行处理。

* 单链表的奇偶链表

  * 问题：将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。
  * 思路：双指针，拉链解法。even指针指向偶节点，odd指针指向奇节点，依次逻辑删除实现拉链解耦。最后偶链尾指向奇链头。[实例](.\datastruct\SingleList_5.cpp)
  * 要点：奇链在后，所以以奇链的移动指针作为循环结束的条件。

* 单链表的反转

  * 法一：newhead法
    * 思路：将节点依次放到最开始，成为新的头节点。[示例](.\datastruct\SingleList_3.cpp)
    * 要点：1. 创建fakehead来记录头节点（指向最新的头节点，每次移动后更新） 2.pre节点不动（即指向原来的头节点），cur节点在pre之后，每次移动cur，并将其更新至后一节点 3.当cur到达null后停止

* 回文链表

  * 问题：判断该链表是否为回文链表
  * 思路：对链表的前半部分进行反转，然后再依次比较两个链表的节点的值。[示例](.\datastruct\SingleList_6.cpp)
  * 要点：
    * 链表长度奇数偶数时反转不一样，（奇数相对于偶数少反转一次）。所以**奇数节点时候slow指针要多加一次**，指向中间节点的后一个节点。
    * 判断奇数偶数节点时，**要先判断是否为偶数，再判断是否为奇数**。
    * **反转链表时，要用特殊方案**：加入空节点作为反转链表的尾节点；并且要先移动快指针。

* 合并两个有序链表

  * 问题：将两个升序链表合并为一个新的 **升序** 链表并返回。
  * 思路：递归算法。将两链表头的两个值进行进行比较，值小的节点取出，将剩下的作为两条新的子链表继续合并。依次操作，直到某一表为空。[示例](.\datastruct\MergeTwoLists.cpp)
  * 要点：
    * 因为是升序排序，值小的节点就会被拿出来。
    * 当某一条子链表为空时，则返回另一条链表。

* 两数相加

  * 问题：使用两个非空链表，表示两个非负整数，数字按逆序排列（低位在头节点），每点储存一位数字。将两数相加，然后返回一个表示和的链表。
  * 思路：两个指针分别指向两链表头，当前节点值相加，结果存储至**和数**和**标志位**（类似于加法器构造），然后放入新节点，依次操作。[示例](.\datastruct\AddTwoNumbers.cpp)
  * 要点：
    * 循环操作结束的条件是**两指针不为空且标志位不为0**。是标志位不为0，不是和数不为0，因为和数的值在循环中会赋值给当前节点，而标志位的值是赋值给下一个节点。
    * 循环中先更新进位标志，再更新和数。
    * answer链表的更新步骤是，先构造下一个节点，再赋值。因此**结果是从第二个节点开始存放的，头节点的存在本质上是虚拟节点**，最后返回从第二个节点开始返回。类似的操作步骤都可以用这种虚拟节点的方法。

* 旋转链表

  * 问题：给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。
  * 思路：先让链表成环并同时统计链表长度；再转动环；再断开环。[示例](.\datastruct\RotateRight.cpp)
  * 要点：
    * 移动k个位置，k可能会大于链表长度，因此先令k=k%n。
    * 断开处节点的下标分别为(n-k-1)和(n-k)。将pre指针从头结点移动到(n-k-1)节点只需移动(n-k-2)次。
    * 返回pre->next节点。


### 循环链表

* 循环链表：

  * 判断链表是否有环：快慢指针技巧。慢指针每次走一步，快指针每次走两步。当快慢指针相遇，即有环；当快指针为空了，即没有环。[示例](.\datastruct\CircleList.cpp)。

  * 判断链表环入口节点位置：

    思路：**快慢指针寻找相遇节点，两慢指寻找入口节点**。先用快慢指针寻找到相遇节点；再同时用**两个慢指针**分别从**相遇节点和head节点**出发，下一次相遇的即为入口节点。

    编程实现逻辑如下，[示例](.\datastruct\CircleList_2.cpp)

    1. 判断链表是否为空或者只有头节点。（是即没有环）
    2. 定义快慢指针，**都指向头节点**。
    3. 寻找相遇节点
       1. 快指针、慢指针前移
       2. 判断是否相等
    4. 判断是否有相遇节点（看fast节点是否在表中）
       1. 若是，则寻找入口节点（两慢指针同时前进）
       2. 若否，则无。

    <img src="https://pic.leetcode-cn.com/1623750708-inrvVm-1623750459597.jpg" alt="1623750459597.jpg" style="zoom: 15%;" />

### 相交链表

* 相交链表：

  * 问题：两相交链表，寻找相交节点。

  * 解决方案：**双指针，两层暴力循环**。指针1走A表，到底后转B表；指针2走B表，到底后转A表。若有相交点，中途会出现指针内容相等。若没有相交点，则最后都指向空。[实例](.\datastruct\CrossList.cpp)

  * 示意图：

    <img src="C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220315170202243.png" alt="image-20220315170202243" style="zoom:50%;" />

  * 要点：即使两链表没有相交点，但两次循环过后，指针1和指针2都同时走完两表，然后分别指向空（即尾节点的下一节点`tail->next`）。

## 双链表

* 双链表基本操作

  * 添加节点：先操作cur节点，再操作pre节点和next节点。可以使用**虚拟头节点和虚拟尾节点**，是的添加操作统一。

  * 删除操作：跳过cur，直接pre和next进行连接。分情况讨论：

    * 删除一般头节点：1、原头结点的下一个节点的prev指向null；2、原头结点的next指向null；3、将原头结点的下一个节点设为头节点；
    * 删除只有头节点：head返回为空
    * 删除一般节点：pre和next直接连接。
    * 删除尾节点：pre直接指向null，删除cur后，不需要再指回pre。

## 二叉树

* 二叉树的遍历方法：

  * 前序遍历：中左右顺序

    ```c++
    void PreOrderTraverse(BiTree T)
    {
    	if (T ==NULL)
    	{
    		return;
    	}
    	printf("%c", T->data);		// 显示节点数据，也可改为其他操作
    	PreOrderTraverse(T->leftchild);
    	PreOrderTraverse(T->rightchild);
    }
    ```

  * 中序遍历：左中右顺序

    ```c++
    void InOrderTraverse(BiTree T)
    {
    	if (T ==NULL)
    	{
    		return;
    	}
    	InOrderTraverse(T->leftchild);
    	printf("%c", T->data);		// 显示节点数据，也可改为其他操作	
    	InOrderTraverse(T->rightchild);
    }
    ```

  * 后序遍历：左右中顺序

    ```c++
    void PostOrderTraverse(BiTree T)
    {
    	if (T ==NULL)
    	{
    		return;
    	}
    	PostOrderTraverse(T->leftchild);
    	PostOrderTraverse(T->rightchild);
    	printf("%c", T->data);		// 显示节点数据，也可改为其他操作    
    }
    ```

* 二叉树的建立：方法类似于二叉树的遍历，不同的地方是把读取节点数据改为创建节点。

  * 按前序方法建立二叉树：

    ```c++
    void CreatBiTree(TreeNode** treenode, char *c)       // 前序遍历法创建二叉树
    {
        char ch;
        ch = *c;
        if(ch == '#')
        {
            treenode = nullptr;
            c = c+1;
        }
        else
        {
            TreeNode * node = new TreeNode();
            (*treenode) = node;
            (*treenode)->val = ch;
            c = c+1;
            CreatBiTree(&(*treenode)->left, c);
            CreatBiTree(&(*treenode)->right, c);
        }
    }
    ```

* 推导遍历结果：通过两种遍历顺序，来确定整个二叉树的构造。方法是利用中序遍历来确定中间节点，利用前序或者后序遍历来确定左右子节点，然后依次递归操作。

* 赫夫曼树：带权路径最短的二叉树。用于**赫夫曼编码**，来解决远距离通信的数据传输的最有问题。其具体原理是按数据出现频率的不同，设计不同长度的编码。

* 树转换为二叉树：1.兄弟节点连线 2.只留长子的连线，删除其他节点的连线

* 线索二叉树：线索化的过程就是在遍历的过程中修改空指针的过程。利用ltag、rtag来确定指针是指向前驱还是后继。

## 数组

### 1.二分查找

* 问题：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
* 思路：通过二分查找，逐渐逼近目标值。[leetcode-704](.\leetcode\array\Search.cpp)
* 要点：
  * 利用二分法，当区间中间位置的值大于目标值，区间向左收缩；当区间中间位置的值小于目标值，区间向右收缩。
  * 二分查找有两种写法，一种是左闭右闭；另一种是左闭右开。两者的比较条件和下标变换方法不一样。
  * 作答采用**左闭右开**的写法。left起始下标为0，right起始下标为nums.size()（最大下标值+1，因为右区间不取等）。当向左收缩时，right=mid；当向右收缩时，left=mid+1（因为left可以被取到）。

### 2.移除元素

* 问题：给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
* 思路：法一：暴力双循环。法二：快慢指针，进行前后覆盖。[leetcode-27](.\leetcode\array\RemoveElement.cpp)
* 要点：
  * 数组元素在内存地址中是连续的，不能单独删除某个元素，只能**从后往前移动进行覆盖**。
  * 保持快指针每一次循环都移动；慢指针只有快指针不等于目标值（此时进行覆盖操作）才移动。（**相当于每次循环快慢指针都移动，且交换；但快指针遇到目标值一次，慢指针的移动和交换就停滞依次**）
  * 快指针位置的值等于目标值时，只有快指针移动；快指针位置的值不等于目标值时，快慢指针都移动。最终快慢指针的位置差刚好等于目标值出现的次数。
  * 快指针到数组尾时循环结束。

### 3.有序数组的平方

* 问题：给你一个按 非递减顺序 排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
* 思路：法一：暴力排序。法二：双指针，将结果按大到小的顺序依次放入新数组。[leetcode-977](.\leetcode\array\SortedSquares.cpp)
* 法一要点：
  * 利用sort进行排序。`sort(A.begin(), A.end());`
* 法二要点：
  * 非递减顺序排序的数组，其平方数的最大值在数组两边。
  * 快慢指针分别指向原数组头和原数组尾，快指针从尾，慢指针从头，分别往中间走。
  * **循环结束的条件：慢指针超过快指针。**（快慢指针相遇时放最后一个元素）

### 4.长度最小的子数组

* 问题：给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
* 思路：法一：暴力解法。法二：滑动窗口法（双指针），取窗口内的为子数组。若子数组总和小于目标值，窗口扩大（快指针前移）；若子数组总和大于等于目标值，窗口缩小（慢指针前移）。[leetcode-209](.\leetcode\array\MinSubArraylen.cpp)
* 要点：
  * 窗口扩大时，每次快指针只移动一次；窗口缩小时，**慢指针前移直到子数组综合小于目标值**。
  * 若子数组总和等于目标值属于窗口缩小的情况。
  * 窗口扩大缩小时通过加减来改变子数组总和值。
  * 子数组最大长度最开始定义为MAX值，**缩小时候通过比较来更新子数组长度**。**最后要判断是否有子数组满足条件，从而决定返回子数组长度还是返回-1。**

### 5.螺旋矩阵Ⅱ

* 问题：给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

* 思路：**坚持循环不变量原则进行填充**。将一个圈分为四条边，依次顺时针填充，填充完后填充下一圈。[leetcode-59](.\leetcode\array\GenerateMatrix.cpp)

  <img src="C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220323223714219.png" alt="image-20220323223714219" style="zoom:50%;" />

* 要点：

  * 坚持循环不变量原则，四条边的定义要固定。
  * 定义辅助变量：起始坐标（startx, starty），填充边的边长（len），总圈数（count），填充元素值（element）。起始坐标初值为0，每次循环（填充完一圈）+1;填充边长初值为n-1，每次循环-2；总圈数初始值为n/2（分奇数偶数）,每次循环-1；填充元素值每次+1。
  * n为奇数偶数最大的区别在于最后一圈。当n为奇数时，最中间的单格无法构成一圈，需要**最后单独填充**。

## 字符串

### 1.反转字符串

* 问题：将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

* 思路：本质就是数组的反转。利用双指针，指向头尾，依次交换，然后向中间靠拢。[leetcode-344](.\leetcode\string\ReverserString.cpp)

* 要点： 

  * 可以利用`swap()`函数实现交换功能。

  * 头指针增加，尾指针减小，当头指针索引值大于等于尾指针时，结束循环。

### 2.反转字符串2

* 问题：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

* 思路：定位起始索引位置，然后反转字符串，再移动定位。

* 要点：

  * 最后一段字符串时，要根据反转字符串长度是否够k来进行分支处理。

  * 字符串的反转不是核心算法，可以利用`reverse()`库函数来实现。

  * 调用`reverse(s.begin(), s.end())`库函数要包含算法库`# include <algorithm>`；其反转区间是左闭右开。即begin处的元素会被反转，end处的元素不会被反转。

### 3.替换空格

* 问题：请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

* 思路：双指针。先利用单指针搜索空格数`count`；然后将字符串长度扩充`2*count`；再利用双指针从后往前进行**元素移动和空格替换**。[剑指offer-05](.\leetcode\string\ReplaceSpace.cpp)

* 要点：

  * `string s`定义字符串，也可以利用数组操作来选取元素，将`s`作为头地址，选取索引为`i`的字符`s[i]`。

  * 扩充字符串的方法`s.resize(len)`，类似于容器重新分配大小。

  * 双指针起点：慢指针索引指向原字符串尾；快指针索引指向新字符串尾。

  * 元素替换和空格移动：当慢指针元素不等于空格时，慢指针元素移动到快指针处，快慢指针索引各减一；当慢指针元素等于空格时，空格移动到快指针处，然后空格替换为`%20`，**慢指针索引减一，快指针索引减三（一个空格字符替换为`%20`三个字符）**；

### 4.KMP算法

* 简介：KMP算法是一种用于字符串匹配的算法。其主要思想是当字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息，避免从头越再去做匹配。

* 名词介绍：

  * 前缀：包含字符串首字母，不包含尾字母的子串。

  * 后缀：包含字符串尾字母，不包含首字母的子串。

  * 前缀表：也称为`next`数组。**其作用是用于回退**。它记录了模式串于主串不匹配时，模式串应该从哪里重新开始匹配的信息，**这一信息具体是下标i（包括i）的字符串中，有多大长度的相同前缀后缀（也称为最大公共子串长度）**。

* 求解前缀表的思路：通过类似于双指针的操作进行比对，然后记录各个位置的最大公共子串长度。具体分为四步。[示例](./leetcode/string/KMP_GetNext.cpp)

  1. 初始化
  2. 前后缀字符不相同时：索引回退
  3. 前后缀字符相同时：索引加1
  4. 更新next数组

* 要点：

  * 一般用i作为索引指向后缀末尾位置，用j作为索引指向前缀末尾位置（同时也是最大公共子串长度）
  * 初始化`next[0]`和j。j的更新在步骤2或3进行索引变更；i的更新在每次循环+1。
  * **回退时可能回退多次**，因此用while循环，且要保证索引`j>0`。算法的核心在于回退，**回退关键代码是`j = next[j-1];`**。

### 5.实现strStr（在文本串中寻找模式串的起始位置）

* 问题：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

* 思路：借助KMP算法，利用双指针实现文本串和模式串的比对，从而寻找出起始位置。[示例](./leetcode/string/StrStr.cpp)

* 要点：
  * 比对过程，非常类似于KMP算法的实现过程，也可分为四个阶段：1.初始化 2.文本串字符和模式串字符相等时的操作（模式串索引回退） 3.文本串字符和模式串字符相等时的操作（模式串索引加一） 4.判断模式串索引是否到串尾了
  * i为文本串索引，j为模式串索引，**初始化时候初始化j和前缀表**
  * 模式串索引的更新依赖于step2和step3,；文本串索引的更新依赖于每次循环+1
  * 模式串索引是否到串尾（索引值等于字符串长度）。当索引到串尾时，返回模式串起始位置（利用文本串索引和模式串长度来判断）。

### 6.重复的字符串

* 问题：给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

* 思路：先获取前缀表，利用前缀表中最后一个元素获取整个字符串的最大公共子串长度；再利用总长度减去最大公共子串长度，得到第一个周期的长度。若是第一个周期的长度可以被字符串长度整除，则说明字符串周期循环，可以由子串多次重复构成。[示例](./leetcode/string/RepeatedSubstringPattern.cpp)

* 要点：
  * 判断可以被整除前，先要判断最大公共子串长度是否为0。

### 7.左旋转字符串

* 问题：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。
* 思路：通过三次字符串旋转达到左旋目的。1.旋转前n个字符构成的子串 2.旋转n个字符构成子串之外的字符字串 3.旋转整个字符串。[示例](./leetcode/string/ReverseLeftWords.cpp)

## 栈与队列

### 1.栈实现队列

* 问题：使用栈实现队列的下列操作：

1. push(x) -- 将一个元素放入队列的尾部。
2. pop() -- 从队列首部移除元素。
3. peek() -- 返回队列首部的元素。
4. empty() -- 返回队列是否为空。

* 思路：利用两个栈实现队列。其中一个栈为输入栈；另一个栈为输出栈。[示例](./leetcode/stackandqueue/MyQueue.cpp)

* 要点：
  * queue.push()时：数据入输入栈。
  * queue.pop()时：若输出栈有数据，直接输出栈输出数据；若输出栈没数据，则先将输入栈数据依次转入输出栈，再从输出栈出数据。
  * queue.peek()时：整个队列出数据（调用queue.pop()），再讲数据放入输出栈。
  * queue.empty()时:判断输出栈和输入栈是否同时为空。

### 2.队列实现栈

* 问题：使用队列实现栈的下列操作push(x) -- 元素 x 入栈；pop() -- 移除栈顶元素；top() -- 获取栈顶元素；empty() -- 返回栈是否为空。

* 思路：利用一个队列实现栈。[示例](./leetcode/stackandqueue/MyStack.cpp)

* 要点：
  * stack.push():数据入队列。
  * stack.pop():队列的前n-1个元素从自身front（pop from front）进到back（push to back），然后获取得到目标元素进行输出和删除。
  * stack.top():获取front元素。队列的前n-1个元素从自身front进到把back，然后将目标元素输出，再将目标元素从front放进back。
  * stack.empty():判断队列是否为空。

### 3.有效括号

* 问题：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

* 思路：利用堆栈，实现括号的匹配。

* 要点：
  * 遍历时，遇到左括号，就对应的右括号进栈。
  * 遇到右括号，与栈顶元素相匹配，若相等，则栈顶元素出栈；若不等，直接返回false。**这一步也要判断栈是否不空**。
  * 遍历完后若栈不为空，也说明括号不匹配，直接返回false。

### 4.删除字符串中的相邻重复项

* 问题：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。

* 思路：利用栈，进行重复字符的消除。当栈顶字符与当前字符相等时，消除，即栈顶字符出栈；当栈顶字符与当前字符不等时，不消除，即当前字符入栈。

* 要点：
  * 最终栈中所有字符**出栈后反序**，才能得到结果所要的字符串。

### 5.逆波兰表达式求值

* 问题：根据 逆波兰表示法，求表达式的值。有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

* 思路：利用栈实现的计算器。由于已经是逆波兰表达式，因此只需利用一个栈存储运算数字，遇到运算符号直接进行运算就可以。

* 要点：
  * 判断表达式的当前字符是不是运算符。若是，则弹出栈顶两数字进行运算；若不是，则将当前数字入栈。
  * 利用数字进行运算时，对于减法和除法，**要注意减数被减数、除数被除数的顺序**。
  * 运算完成后后，要将结果入栈。
  * 数字入栈前是字符串形式，要利用`stoi()`函数将其转为数字。
  * stoi函数申明`stoi(string str, int begin, int end)`。

## 哈希表

### 0.哈希表基础

* 哈希表常用数据结构：数据、set（集合）、map（映射）
  * set：
  
    ![image-20220407174501355](C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220407174501355.png)
  
  * map：
  
    ![image-20220407174515533](C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220407174515533.png)

### 1.有效的字母异位词

* 问题：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。（即是否打乱了字符顺序）

* 思路：利用数组实现一个简单的哈希表。在哈希表中记录字符出现次数。s字符串的字符出现则在哈希表中增加次数；t字符串的字符出现则在哈希表中减少次数。最后判断哈希表中元素是否全为0。

* 要点：
  * 构造哈希函数，将字符映射到哈希表上的索引。利用字符的顺序，作为数组的索引位置。

### 2.两个数组的交集

* 问题：给定两个数组，编写一个函数来计算它们的交集。

* 思路：利用unordered_set实现对数组1的去重，再查看数组2中的元素是否出现在数组1的去重结果中，如果出现，就记录下来，最后输出。

* 要点：
  * 利用unordered_set容器，因为其元素数值不可以被重复。
  * 本质上对数组1和数组2都要去重，所以有两次去重。因此数组1要用unordered_set去重一次；记录的结果放在unordered_set中相当于再去重一次。
  * 利用自带的移动构造函数直接实现容器的转换。示例：`unordered_set<int> nums1_set(nums1.begin(), nums1.end());`和`vector<int> (result.begin(), result.end())`。
  * 利用unordered_set的find函数查看元素是否已经被记录。